ФУНКЦИИ

Причины использования функций:
     - помогают переиспользовать код. Т.е. использование кода во многих местах без
     копирования
     - чистота кода и его структурирование.
     - сокрытие деталей реализации.

Синтаксис:

def function_name(arg1, arg2):
    #some code

Функции в языке пайтон так же составляют объект.
Функции не исполняются интерпритатором целиком, сначала читается до конца функции а потом
идет исполнение

Объект функции хранит в себе Название функции, Аргументы которые принимает функция и
, самое главное, тело функции.

В самом начале функции - происходит инициализация переменных в функции, т.е. параметры функции
(в примере arg1 и arg2) начинают ссылаться на аргументы которые передаются при вызове функции
При каждом вызове функции параметры функции инициализируются заново


СТЕК ВЫЗОВОВ

Стек вызовов хранит функции которые мы исполняем. Интерпритатор кладет функцию в стек
вызовов когда начинает ее выполнение и снимает ее со стека по завершении выполнения.
Т.е. СТЕК ВЫЗОВОВ ОТОБРАЖАЕТ ВСЕ ФУНКЦИИ КОТОРЫЕ ОЖИДАЮТ ЗАВЕРЩЕНИЯ ФУНКЦИИ НАВЕРХУ СТЕКА
стек при вызове программы содержит функцию MODULE

после выполнения конструкции return функция завершает свою работу не исполняя все что ниже.
но функция может не возвращать никакого значения.
ЕСЛИ ФУНКЦИЯ НИЧЕГО НЕ ВОЗВРАЩАЕТ ИЛИ ИСПОЛЬЗУЕТ ПУСТОЙ РЕТЕРН ТО ВОЗВРАЩАЕТСЯ ОБЪЕКТ NONE
тип объекта NONE - NoneType. Единственная проверка на то ссылается ли объект на None:
x is None

АРГУМЕНТЫ ФУНКЦИИ

def printab(a, b):
    print(a)
    print(b)

при передаче аргументов функции важно чтобы количество параметров было равно количеству
аргументов
printab(1, 3) - позиционная передача аргументов ( а = 1, b = 3)
printab( a = 3, b = 1) - именованая передача аргументов
Возможны комбинации:
printab(10, b = 20) - важно что всегда сначала передаются позиционные аргументы а потом
                      именованые

возможна передача аргументов списком:
lst = [10, 20]
printab(*lst) - эквивалентно передаче вида printab(lst[0], lst[1])

или словарем в случае именованых аргументов
args = {"a": 10, "b": 20}

printab(**args) - эквивалентно записи вида printab(args["a"], args["b"])

Значения по умолчанию:
def printab(a, b=10)
    print(a)
    print(b)

при вызове функции можно вызвать и printab(5, 15) и printab(5) - во втором случае интерпри
татор будет считать что b = 10

аргументы по умолчанию указываются всегда в самом конце


В языке Python реализован механизм который позволяет передать функции неопределенное
количество аргументов:
def printab(a, b, *args):
    print("positional argument a", a)
    print("positional argument b", b)
    print("additional arguments:")
    for arg in args:
        print(arg)


в подобной реализации вызов этой функции такого вида
printab(10, 20, 30, 40, 50)

будет таким:
positional argument a 10
positional argument b 20
additional arguments:
30
40
50

Для именованых аргументов схожий механизм

def printab(a, b, **kwargs):
    print("positional argument a", a)
    print("positional argument b", b)
    print("additional arguments:")
    for key in kwargs:
        print(key, kwargs[key])

вызов:
printab(10, 20, c = 30, d = 40, jimmi = 123)

вывод:
positional argument a 10
positional argument b 20
additional arguments:
d 40
jimmi 123
c 30

СИНТАКСИЧЕСКИ ВЕРНОЕ ОПРЕДЕЛЕНИЕ ФУНКЦИИ:
def function_name([positional_args,
                  [positional_args_with_default,
                  [ *pos_args_name,
                  [keyword_only_args,
                  [ **kw_args_name]]]]]):
