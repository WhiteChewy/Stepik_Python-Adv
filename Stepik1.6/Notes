НАСЛЕДОВАНИЕ КЛАСОВ

Синитаксис

clas DerivedClassName(Bas1, Base2, Base3):
    <statment-1>
    .
    .
    .
    <statment-n>


Например можно написать расширение для класса list в Python

class MyList(list):
    def even_length(self):
        return len(self) % 2 == 0

x = MyList()
print(x) # []
x.extend([1, 2, 3, 4, 5]) # вызывается корректно так как не найдя имя extend в
                          # неймспейсах экземпляра и класса мы ищем его в неймспейсе "родителя"
print(x) # [1, 2, 3, 4, 5]
print(x.even_length()) # False
x.append(6)
print(x.even_length()) # True

Множественное наследование

-//- - это когда один класс наследуется от нескольких "родителей"
ВСЕ КЛАСССЫ В ПАЙТОН НАСЛЕДУЮТСЯ ОТ КЛАССА Object.

Проще всего понять что такое множественное наследование через графы:
                            Object
                            / | \
                           /  |  \
                          /   |   \
                         /    |    \
                         D    E     \
                         \    /      C
                          \  /       /
                           B        /
                           \       /
                            \     /
                             \   /
                              \ /
                               A

Данный рисунок описывается следующим учатском кода:
class D: pass
Class E: pass
class B(D, E): pass
class C: pass
class A(B, C): pass

Согласно теории графов В является предком А точно так же как и С, но и D и Е явлются
предками A. Для того чтобы проверить это есть стандартное средство языка Pyhton:
issubclass() возвращает булево значение
надо сделать пометку что любой класс является предком самого себя, т.е.
issubclass(A, A) возвращает True

Так же есть функция проверки является ли объект типом класса (или класса предка):
x = A()
isinstance(x, A) # True

По сути функция isinstance показывает может ли объект использоваться как объект данного типа

При множественном наследовании в каком порядке перебираются классы для поиска имени
неймспейса
Для этого существует понятие Порядо Разрешения Методов
Его мождно получить выполнив метод mro:
print(A.mro())
данный метод возвращает список в котором содержится по порядку последовательность предков для
поиска

при множественном наследовании гарантируется что просмотр неймспейсов будет в порядке
объявления предков
Иногда требуется вызвать метод класса-предка, для этого есть функция супер, которая
принимает 2 фаргумента:
1) класс родителей которого мы хотим проверить
2) объект с которым мы хотим проассоциировать метод
x = super(MyList, self.pop())
